# 이분 탐색 
> [!important]
> - 탐색하고 싶은 범위를 2개로 나눠서 찾는 법 
> - 시간복잡도: `O(logN)`

## ✅ 이분 탐색하는 방법 -- 나랑 일치하는 값 있는지 찾기 
1. 배열 정렬 
2. left, right를 배열의 양 끝으로 설정 
3. mid = (left + right) / 2 로 설정 
    - arr[mid] > target : left = mid + 1 
    - arr[mid] < target : right = mid - 1
    - arr[mid] == target : break 
4. left > right 가 될 때까지 반복한다 

## 🚀 예제: 실버2 15810 백준 풍선공장 

- N명의 스태프
- M개의 풍선 만들기

**✅ 이분 탐색으로 문제를 풀어야 할 때 해볼 수 있는 생각의 흐름** 

1. 무엇을 탐색할 것인가?  
   - 구하고자 하는 최종 답: 풍선 M개 만드는데 걸리는 최소 시간 
   - left, right, mid -> 우리가 구하고자 하는 정답일 확률이 높다 
   - -> 이분 탐색으로 조절하며 짝을 맞춰봐야 하는 변수 mid = 시간 
   - => mid라는 시간이 주어진다면, 스태프들은 풍선 몇 개를 만들 수 있을까? 

2. 조건 판단하기 
   - mid를 총 시간으로 설정했을 때 이제 이 사간이 충분한지 부족한지 판단하는 로직 
   - 모든 스태프의 (주어진 시간 mid / 스태프i의 작업 속도)의 합 >= M (목표 개수) 
   - -> 만약 true면 널널하단 뜻이니까 high--
   - -> 만약 false면 시간 부족한 거니까 low++ 

3. 범위 주의하기 
   - N: 10^6
   - 풍선 개수 M: 최대 10^6
   - 걸리는 시간 Ai: 최대 10^6
   - 최악의 경우 걸리는 시간: 모두가 10^6이 걸려서 10^12일 수 있겠네 

## 🚀 예제: 골드5 28449 누가 이길까?
> 이분탐색으로 푸는 문제는 맞다. 
> - 그러나 경계(boundary)를 찾는 이분탐색
> - 그래서 left, right, mid를 쓰는 방식이 다름 

### 1. 먼저 "내가 이분탐색으로 무엇을 찾는지"룰 한 문장으로 고정하기 
- 문제에서 필요했던 거: "원소 위치"가 아닌 **"개수"** 
  - `win(X)`이면 상대에서 `< X`인 개수 
  - `draw(X)`이면 상대에서 `== X`인 개수 
- 정렬된 상대의 배열에서 이걸 계산한다고 하면 
  - `win(X)`는 **처음으로 `>= X`가 되는 인덱스` 찾는 거임**
  - `draw(X)`는 **(처음 `> X`인 인덱스) - (처음 `>= X인 인덱스)` 
- 그러니까 "X 찾기"가 목적이 아니라 **조건이 처음으로 참이 되는 지점**을 찾아야 함 

### ⭐ 2. 즉, 정답 후보를 버리면 안된다 
- 여기서는 `mid` 위치에 놓인 값이 답이 될 수 있기 때문에 
- 조건을 만족하는 쪽 안에서 mid를 포함해서 범위를 줄여야됨

> lower_bound(처음 >= x):
> - `arr[mid] >= x` 면 → 정답이 mid일 수도 있으니 버리면 안 됨 
>   - → right = mid 
> - `arr[mid] < x` 면 → mid는 절대 정답 아님 
>   - → l = mid + 1

여기서 헤매는 이유가
- “값 찾기”는 보통 ==를 만나면 return 하니까 mid를 버려도 됨 
- “경계 찾기”는 `==` 만나도 더 왼쪽에 같은 값이 있을 수 있으니 계속 가야 함

> ✅ ==을 “종료 조건”으로 생각하면 틀린다
